#! /usr/bin/env ruby
#
# ActiveFacts: Read a model (CQL, ORM, etc), run a compositor, then a generator
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)
require 'bundler/setup' # Set up gems listed in the Gemfile.
$:.unshift File.dirname(File.expand_path(__FILE__))+"/../lib"

require 'activefacts/loadable'
require 'activefacts/metamodel'
require 'activefacts/compositions'
require 'activefacts/generators'

# Parse options into a hash:
options = {}
while ARGV[0] =~ /^-/
  option, value = ARGV.shift.split(/=/, 2)
  options[option.sub(/^-*/,'')] = value =~ /,/ ? value.split(',') : (value || true)
end

# Load and enumerate all available compositors:
compositions_path = "activefacts/compositions"
Loadable.new(compositions_path).
enumerate.
select do |filename|
  begin
    require(compositions_path+"/"+filename)
  rescue Exception
  end
end

# Load and enumerate all available generators
generators_path = "activefacts/generators"
Loadable.new(generators_path).
enumerate.
select do |filename|
  begin
    require(generators_path+"/"+filename)
  rescue Exception
  end
end

# Arrange the requested compositors and generators:
compositors = []
generators = []
options.clone.each do |option, value|
  if compositor = ActiveFacts::Compositions.compositors[option]
    options.delete(option)
    compositors << compositor
  elsif generator = ActiveFacts::Generators.generators[option]
    options.delete(option)
    generators << generator
  end
end

if options['help']
  puts "Available compositors:\n\t#{ActiveFacts::Compositions.compositors.keys.sort*"\n\t"}\n\n"
  puts "Available generators:\n\t#{ActiveFacts::Generators.generators.keys.sort*"\n\t"}\n\n"
  exit
end

ARGV.each do |arg|
  filename, input_options = *arg.split(/=/, 2)

  # Load the correct file type input method
  pathname, basename, extension = * /(?:(.*)[\/\\])?(.*)\.([^.]*)$/.match(filename).captures
  input_handler = "activefacts/input/#{extension}"
  require input_handler

  input_class = extension.upcase
  input_klass = ActiveFacts::Input.const_get(input_class.to_sym)
  raise "Expected #{input_handler} to define #{input_class}" unless input_klass

  # Read the input file:
  vocabulary =
    if input_klass
      begin
	input_klass.readfile(filename, *input_options)
      rescue => e
	$stderr.puts "#{e.message}"
	$stderr.puts "\t#{e.backtrace*"\n\t"}" if trace :exception
	exit 1
      end
    end
  exit 0 unless vocabulary
  vocabulary.finalise unless vocabulary == true

  # Run each compositor
  compositors.each do |compositor_klass|
    compositor = compositor_klass.new(vocabulary.constellation, basename, options)
    compositor.generate

    # Run each generator
    generators.each do |generator|
      output = generator.new(compositor.composition).generate
      puts output if output
    end
  end
end
