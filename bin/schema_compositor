#! /usr/bin/env ruby
#
#       ActiveFacts: Read a Vocabulary (from a NORMA, CQL or other file) and run a generator
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)
require 'bundler/setup' # Set up gems listed in the Gemfile.
$:.unshift File.dirname(File.expand_path(__FILE__))+"/../lib"

require 'activefacts/metamodel'
require 'activefacts/compositions/binary'
require 'activefacts/compositions/relational'
require 'activefacts/compositions/validator'

options = {}
while arg = ARGV.shift and arg =~ /^-/
  option, value = arg.split(/=/, 2)
  options[option.sub(/^-*/,'')] = value =~ /,/ ? value.split(',') : (value || true)
end

validate = options.delete('validate')
show = options.delete('show')

# Load the file type input method
if arg
  arg, input_options = *arg.split(/=/, 2)
  extension = arg.sub(/\A.*\./,'').downcase
  input_handler = "activefacts/input/#{extension}"
  require input_handler

  input_class = extension.upcase
  input_klass = ActiveFacts::Input.const_get(input_class.to_sym)
  raise "Expected #{input_handler} to define #{input_class}" unless input_klass
end

# Read the input file:
begin
  if input_klass
    vocabulary = input_klass.readfile(arg, *input_options)
  else
    vocabulary = true
  end

  exit 0 unless vocabulary

  vocabulary.finalise unless vocabulary == true

  compositor = ActiveFacts::Compositions::Relational.new(vocabulary.constellation, "test", options)
  compositor.generate

  if validate
    trace.enable 'composition_validator'
    compositor.validate do |component, problem|
      trace :composition_validator, "!!PROBLEM!! #{component.inspect}: #{problem}"
    end
  end

  if show
    compositor.
    composition.
    all_composite.
    sort_by{|composite| composite.mapping.name}.
    each do |composite|
      puts composite.mapping.name
      indices = composite.all_indices_by_rank

      composite.mapping.leaves.each do |leaf|
	# Build a symbolic representation of the index participation of this leaf
	pos = 0
	indexing = indices.inject([]) do |a, index|
	  pos += 1
	  if part = index.position_in_index(leaf)
	    a << "#{pos}.#{part}"
	  end
	  a
	end

	puts "\t#{leaf.path.map{|component|
	    if component.is_a?(ActiveFacts::Metamodel::Absorption) && component.foreign_key
	      "[#{component.name}]"
	    else
	      component.name
	    end +
	      (component.is_a?(ActiveFacts::Metamodel::Absorption) && !component.parent_role.is_mandatory ? '?' : '')
	  }*'->'}" +
	  (indexing.empty? ? '' : "[#{indexing*','}]")	# Show the indexing
      end
    end
  end

rescue => e
  $stderr.puts "#{e.message}"
  # puts "\t#{e.backtrace*"\n\t"}"
  $stderr.puts "\t#{e.backtrace*"\n\t"}" if trace :exception
  exit 1
end
